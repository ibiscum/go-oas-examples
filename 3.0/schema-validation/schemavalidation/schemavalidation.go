//go:build go1.22

// Package schemavalidation provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package schemavalidation

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// GetAnythingBooleansParams defines parameters for GetAnythingBooleans.
type GetAnythingBooleansParams struct {
	TfRequired bool `form:"tf-required" json:"tf-required"`

	// TfOptional Optional boolean
	TfOptional *bool `form:"tf-optional,omitempty" json:"tf-optional,omitempty"`
}

// GetAnythingJsonschemaFormatsParams defines parameters for GetAnythingJsonschemaFormats.
type GetAnythingJsonschemaFormatsParams struct {
	DateTime            time.Time            `form:"date-time" json:"date-time"`
	Date                *openapi_types.Date  `form:"date,omitempty" json:"date,omitempty"`
	Time                *string              `form:"time,omitempty" json:"time,omitempty"`
	Duration            *string              `form:"duration,omitempty" json:"duration,omitempty"`
	Email               *openapi_types.Email `form:"email,omitempty" json:"email,omitempty"`
	IdnEmail            *string              `form:"idn-email,omitempty" json:"idn-email,omitempty"`
	Hostname            *string              `form:"hostname,omitempty" json:"hostname,omitempty"`
	IdnHostname         *string              `form:"idn-hostname,omitempty" json:"idn-hostname,omitempty"`
	Ipv4                *string              `form:"ipv4,omitempty" json:"ipv4,omitempty"`
	Ipv6                *string              `form:"ipv6,omitempty" json:"ipv6,omitempty"`
	Uri                 *string              `form:"uri,omitempty" json:"uri,omitempty"`
	UriReference        *string              `form:"uri-reference,omitempty" json:"uri-reference,omitempty"`
	Iri                 *string              `form:"iri,omitempty" json:"iri,omitempty"`
	IriReference        *string              `form:"iri-reference,omitempty" json:"iri-reference,omitempty"`
	Uuid                *openapi_types.UUID  `form:"uuid,omitempty" json:"uuid,omitempty"`
	UriTemplate         *string              `form:"uri-template,omitempty" json:"uri-template,omitempty"`
	JsonPointer         *string              `form:"json-pointer,omitempty" json:"json-pointer,omitempty"`
	RelativeJsonPointer *string              `form:"relative-json-pointer,omitempty" json:"relative-json-pointer,omitempty"`
	Regex               *string              `form:"regex,omitempty" json:"regex,omitempty"`
}

// GetAnythingNumbersParams defines parameters for GetAnythingNumbers.
type GetAnythingNumbersParams struct {
	IdRequired          float32  `form:"id-required" json:"id-required"`
	IdOptional          *float32 `form:"id-optional,omitempty" json:"id-optional,omitempty"`
	IdExclusiveRequired float32  `form:"id-exclusive-required" json:"id-exclusive-required"`
	IdExclusiveOptional *float32 `form:"id-exclusive-optional,omitempty" json:"id-exclusive-optional,omitempty"`
}

// GetAnythingOasFormatsParams defines parameters for GetAnythingOasFormats.
type GetAnythingOasFormatsParams struct {
	Int32    int32               `form:"int32" json:"int32"`
	Int64    *int64              `form:"int64,omitempty" json:"int64,omitempty"`
	Float    *float32            `form:"float,omitempty" json:"float,omitempty"`
	Double   *float64            `form:"double,omitempty" json:"double,omitempty"`
	Byte     *[]byte             `form:"byte,omitempty" json:"byte,omitempty"`
	Binary   *openapi_types.File `form:"binary,omitempty" json:"binary,omitempty"`
	Password *string             `form:"password,omitempty" json:"password,omitempty"`
}

// GetAnythingStringsParams defines parameters for GetAnythingStrings.
type GetAnythingStringsParams struct {
	NameLengthRequired  string  `form:"name-length-required" json:"name-length-required"`
	NameLengthOptional  *string `form:"name-length-optional,omitempty" json:"name-length-optional,omitempty"`
	NamePatternRequired string  `form:"name-pattern-required" json:"name-pattern-required"`

	// ComplexPatternRequired OpenAPI 3.0.3, which defaults to JSON Schema v4, does not provide the unicode flag to the input tooltip regex validation. This means that the following regex should work. It won't work if unicode is enabled because it has unescaped brace literals
	ComplexPatternRequired string  `form:"complex-pattern-required" json:"complex-pattern-required"`
	NamePatternOptional    *string `form:"name-pattern-optional,omitempty" json:"name-pattern-optional,omitempty"`
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAnythingBooleans request
	GetAnythingBooleans(ctx context.Context, params *GetAnythingBooleansParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnythingJsonschemaFormats request
	GetAnythingJsonschemaFormats(ctx context.Context, params *GetAnythingJsonschemaFormatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnythingNumbers request
	GetAnythingNumbers(ctx context.Context, params *GetAnythingNumbersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnythingOasFormats request
	GetAnythingOasFormats(ctx context.Context, params *GetAnythingOasFormatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnythingStrings request
	GetAnythingStrings(ctx context.Context, params *GetAnythingStringsParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAnythingBooleans(ctx context.Context, params *GetAnythingBooleansParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnythingBooleansRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnythingJsonschemaFormats(ctx context.Context, params *GetAnythingJsonschemaFormatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnythingJsonschemaFormatsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnythingNumbers(ctx context.Context, params *GetAnythingNumbersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnythingNumbersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnythingOasFormats(ctx context.Context, params *GetAnythingOasFormatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnythingOasFormatsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnythingStrings(ctx context.Context, params *GetAnythingStringsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnythingStringsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAnythingBooleansRequest generates requests for GetAnythingBooleans
func NewGetAnythingBooleansRequest(server string, params *GetAnythingBooleansParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anything/booleans")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tf-required", runtime.ParamLocationQuery, params.TfRequired); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TfOptional != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tf-optional", runtime.ParamLocationQuery, *params.TfOptional); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnythingJsonschemaFormatsRequest generates requests for GetAnythingJsonschemaFormats
func NewGetAnythingJsonschemaFormatsRequest(server string, params *GetAnythingJsonschemaFormatsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anything/jsonschema-formats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date-time", runtime.ParamLocationQuery, params.DateTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Time != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time", runtime.ParamLocationQuery, *params.Time); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Duration != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "duration", runtime.ParamLocationQuery, *params.Duration); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Email != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "email", runtime.ParamLocationQuery, *params.Email); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IdnEmail != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "idn-email", runtime.ParamLocationQuery, *params.IdnEmail); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Hostname != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hostname", runtime.ParamLocationQuery, *params.Hostname); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IdnHostname != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "idn-hostname", runtime.ParamLocationQuery, *params.IdnHostname); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ipv4 != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ipv4", runtime.ParamLocationQuery, *params.Ipv4); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ipv6 != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ipv6", runtime.ParamLocationQuery, *params.Ipv6); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Uri != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "uri", runtime.ParamLocationQuery, *params.Uri); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UriReference != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "uri-reference", runtime.ParamLocationQuery, *params.UriReference); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Iri != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "iri", runtime.ParamLocationQuery, *params.Iri); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IriReference != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "iri-reference", runtime.ParamLocationQuery, *params.IriReference); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Uuid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "uuid", runtime.ParamLocationQuery, *params.Uuid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UriTemplate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "uri-template", runtime.ParamLocationQuery, *params.UriTemplate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JsonPointer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "json-pointer", runtime.ParamLocationQuery, *params.JsonPointer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RelativeJsonPointer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "relative-json-pointer", runtime.ParamLocationQuery, *params.RelativeJsonPointer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Regex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "regex", runtime.ParamLocationQuery, *params.Regex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnythingNumbersRequest generates requests for GetAnythingNumbers
func NewGetAnythingNumbersRequest(server string, params *GetAnythingNumbersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anything/numbers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id-required", runtime.ParamLocationQuery, params.IdRequired); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.IdOptional != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id-optional", runtime.ParamLocationQuery, *params.IdOptional); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id-exclusive-required", runtime.ParamLocationQuery, params.IdExclusiveRequired); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.IdExclusiveOptional != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id-exclusive-optional", runtime.ParamLocationQuery, *params.IdExclusiveOptional); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnythingOasFormatsRequest generates requests for GetAnythingOasFormats
func NewGetAnythingOasFormatsRequest(server string, params *GetAnythingOasFormatsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anything/oas-formats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "int32", runtime.ParamLocationQuery, params.Int32); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Int64 != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "int64", runtime.ParamLocationQuery, *params.Int64); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Float != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "float", runtime.ParamLocationQuery, *params.Float); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Double != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "double", runtime.ParamLocationQuery, *params.Double); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Byte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "byte", runtime.ParamLocationQuery, *params.Byte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Binary != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "binary", runtime.ParamLocationQuery, *params.Binary); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Password != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "password", runtime.ParamLocationQuery, *params.Password); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnythingStringsRequest generates requests for GetAnythingStrings
func NewGetAnythingStringsRequest(server string, params *GetAnythingStringsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anything/strings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name-length-required", runtime.ParamLocationQuery, params.NameLengthRequired); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.NameLengthOptional != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name-length-optional", runtime.ParamLocationQuery, *params.NameLengthOptional); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name-pattern-required", runtime.ParamLocationQuery, params.NamePatternRequired); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "complex-pattern-required", runtime.ParamLocationQuery, params.ComplexPatternRequired); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.NamePatternOptional != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name-pattern-optional", runtime.ParamLocationQuery, *params.NamePatternOptional); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAnythingBooleansWithResponse request
	GetAnythingBooleansWithResponse(ctx context.Context, params *GetAnythingBooleansParams, reqEditors ...RequestEditorFn) (*GetAnythingBooleansResponse, error)

	// GetAnythingJsonschemaFormatsWithResponse request
	GetAnythingJsonschemaFormatsWithResponse(ctx context.Context, params *GetAnythingJsonschemaFormatsParams, reqEditors ...RequestEditorFn) (*GetAnythingJsonschemaFormatsResponse, error)

	// GetAnythingNumbersWithResponse request
	GetAnythingNumbersWithResponse(ctx context.Context, params *GetAnythingNumbersParams, reqEditors ...RequestEditorFn) (*GetAnythingNumbersResponse, error)

	// GetAnythingOasFormatsWithResponse request
	GetAnythingOasFormatsWithResponse(ctx context.Context, params *GetAnythingOasFormatsParams, reqEditors ...RequestEditorFn) (*GetAnythingOasFormatsResponse, error)

	// GetAnythingStringsWithResponse request
	GetAnythingStringsWithResponse(ctx context.Context, params *GetAnythingStringsParams, reqEditors ...RequestEditorFn) (*GetAnythingStringsResponse, error)
}

type GetAnythingBooleansResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetAnythingBooleansResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnythingBooleansResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnythingJsonschemaFormatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetAnythingJsonschemaFormatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnythingJsonschemaFormatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnythingNumbersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetAnythingNumbersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnythingNumbersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnythingOasFormatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetAnythingOasFormatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnythingOasFormatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnythingStringsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetAnythingStringsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnythingStringsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAnythingBooleansWithResponse request returning *GetAnythingBooleansResponse
func (c *ClientWithResponses) GetAnythingBooleansWithResponse(ctx context.Context, params *GetAnythingBooleansParams, reqEditors ...RequestEditorFn) (*GetAnythingBooleansResponse, error) {
	rsp, err := c.GetAnythingBooleans(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnythingBooleansResponse(rsp)
}

// GetAnythingJsonschemaFormatsWithResponse request returning *GetAnythingJsonschemaFormatsResponse
func (c *ClientWithResponses) GetAnythingJsonschemaFormatsWithResponse(ctx context.Context, params *GetAnythingJsonschemaFormatsParams, reqEditors ...RequestEditorFn) (*GetAnythingJsonschemaFormatsResponse, error) {
	rsp, err := c.GetAnythingJsonschemaFormats(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnythingJsonschemaFormatsResponse(rsp)
}

// GetAnythingNumbersWithResponse request returning *GetAnythingNumbersResponse
func (c *ClientWithResponses) GetAnythingNumbersWithResponse(ctx context.Context, params *GetAnythingNumbersParams, reqEditors ...RequestEditorFn) (*GetAnythingNumbersResponse, error) {
	rsp, err := c.GetAnythingNumbers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnythingNumbersResponse(rsp)
}

// GetAnythingOasFormatsWithResponse request returning *GetAnythingOasFormatsResponse
func (c *ClientWithResponses) GetAnythingOasFormatsWithResponse(ctx context.Context, params *GetAnythingOasFormatsParams, reqEditors ...RequestEditorFn) (*GetAnythingOasFormatsResponse, error) {
	rsp, err := c.GetAnythingOasFormats(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnythingOasFormatsResponse(rsp)
}

// GetAnythingStringsWithResponse request returning *GetAnythingStringsResponse
func (c *ClientWithResponses) GetAnythingStringsWithResponse(ctx context.Context, params *GetAnythingStringsParams, reqEditors ...RequestEditorFn) (*GetAnythingStringsResponse, error) {
	rsp, err := c.GetAnythingStrings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnythingStringsResponse(rsp)
}

// ParseGetAnythingBooleansResponse parses an HTTP response from a GetAnythingBooleansWithResponse call
func ParseGetAnythingBooleansResponse(rsp *http.Response) (*GetAnythingBooleansResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnythingBooleansResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAnythingJsonschemaFormatsResponse parses an HTTP response from a GetAnythingJsonschemaFormatsWithResponse call
func ParseGetAnythingJsonschemaFormatsResponse(rsp *http.Response) (*GetAnythingJsonschemaFormatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnythingJsonschemaFormatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAnythingNumbersResponse parses an HTTP response from a GetAnythingNumbersWithResponse call
func ParseGetAnythingNumbersResponse(rsp *http.Response) (*GetAnythingNumbersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnythingNumbersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAnythingOasFormatsResponse parses an HTTP response from a GetAnythingOasFormatsWithResponse call
func ParseGetAnythingOasFormatsResponse(rsp *http.Response) (*GetAnythingOasFormatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnythingOasFormatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAnythingStringsResponse parses an HTTP response from a GetAnythingStringsWithResponse call
func ParseGetAnythingStringsResponse(rsp *http.Response) (*GetAnythingStringsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnythingStringsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Booleans
	// (GET /anything/booleans)
	GetAnythingBooleans(w http.ResponseWriter, r *http.Request, params GetAnythingBooleansParams)
	// Formats defined by JSON Schema
	// (GET /anything/jsonschema-formats)
	GetAnythingJsonschemaFormats(w http.ResponseWriter, r *http.Request, params GetAnythingJsonschemaFormatsParams)
	// Number validation
	// (GET /anything/numbers)
	GetAnythingNumbers(w http.ResponseWriter, r *http.Request, params GetAnythingNumbersParams)
	// Formats defined by OpenAPI
	// (GET /anything/oas-formats)
	GetAnythingOasFormats(w http.ResponseWriter, r *http.Request, params GetAnythingOasFormatsParams)
	// String validation
	// (GET /anything/strings)
	GetAnythingStrings(w http.ResponseWriter, r *http.Request, params GetAnythingStringsParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetAnythingBooleans operation middleware
func (siw *ServerInterfaceWrapper) GetAnythingBooleans(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAnythingBooleansParams

	// ------------- Required query parameter "tf-required" -------------

	if paramValue := r.URL.Query().Get("tf-required"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "tf-required"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "tf-required", r.URL.Query(), &params.TfRequired)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tf-required", Err: err})
		return
	}

	// ------------- Optional query parameter "tf-optional" -------------

	err = runtime.BindQueryParameter("form", true, false, "tf-optional", r.URL.Query(), &params.TfOptional)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tf-optional", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAnythingBooleans(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetAnythingJsonschemaFormats operation middleware
func (siw *ServerInterfaceWrapper) GetAnythingJsonschemaFormats(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAnythingJsonschemaFormatsParams

	// ------------- Required query parameter "date-time" -------------

	if paramValue := r.URL.Query().Get("date-time"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "date-time"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "date-time", r.URL.Query(), &params.DateTime)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "date-time", Err: err})
		return
	}

	// ------------- Optional query parameter "date" -------------

	err = runtime.BindQueryParameter("form", true, false, "date", r.URL.Query(), &params.Date)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "date", Err: err})
		return
	}

	// ------------- Optional query parameter "time" -------------

	err = runtime.BindQueryParameter("form", true, false, "time", r.URL.Query(), &params.Time)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "time", Err: err})
		return
	}

	// ------------- Optional query parameter "duration" -------------

	err = runtime.BindQueryParameter("form", true, false, "duration", r.URL.Query(), &params.Duration)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "duration", Err: err})
		return
	}

	// ------------- Optional query parameter "email" -------------

	err = runtime.BindQueryParameter("form", true, false, "email", r.URL.Query(), &params.Email)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "email", Err: err})
		return
	}

	// ------------- Optional query parameter "idn-email" -------------

	err = runtime.BindQueryParameter("form", true, false, "idn-email", r.URL.Query(), &params.IdnEmail)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "idn-email", Err: err})
		return
	}

	// ------------- Optional query parameter "hostname" -------------

	err = runtime.BindQueryParameter("form", true, false, "hostname", r.URL.Query(), &params.Hostname)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "hostname", Err: err})
		return
	}

	// ------------- Optional query parameter "idn-hostname" -------------

	err = runtime.BindQueryParameter("form", true, false, "idn-hostname", r.URL.Query(), &params.IdnHostname)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "idn-hostname", Err: err})
		return
	}

	// ------------- Optional query parameter "ipv4" -------------

	err = runtime.BindQueryParameter("form", true, false, "ipv4", r.URL.Query(), &params.Ipv4)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ipv4", Err: err})
		return
	}

	// ------------- Optional query parameter "ipv6" -------------

	err = runtime.BindQueryParameter("form", true, false, "ipv6", r.URL.Query(), &params.Ipv6)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ipv6", Err: err})
		return
	}

	// ------------- Optional query parameter "uri" -------------

	err = runtime.BindQueryParameter("form", true, false, "uri", r.URL.Query(), &params.Uri)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "uri", Err: err})
		return
	}

	// ------------- Optional query parameter "uri-reference" -------------

	err = runtime.BindQueryParameter("form", true, false, "uri-reference", r.URL.Query(), &params.UriReference)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "uri-reference", Err: err})
		return
	}

	// ------------- Optional query parameter "iri" -------------

	err = runtime.BindQueryParameter("form", true, false, "iri", r.URL.Query(), &params.Iri)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "iri", Err: err})
		return
	}

	// ------------- Optional query parameter "iri-reference" -------------

	err = runtime.BindQueryParameter("form", true, false, "iri-reference", r.URL.Query(), &params.IriReference)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "iri-reference", Err: err})
		return
	}

	// ------------- Optional query parameter "uuid" -------------

	err = runtime.BindQueryParameter("form", true, false, "uuid", r.URL.Query(), &params.Uuid)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "uuid", Err: err})
		return
	}

	// ------------- Optional query parameter "uri-template" -------------

	err = runtime.BindQueryParameter("form", true, false, "uri-template", r.URL.Query(), &params.UriTemplate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "uri-template", Err: err})
		return
	}

	// ------------- Optional query parameter "json-pointer" -------------

	err = runtime.BindQueryParameter("form", true, false, "json-pointer", r.URL.Query(), &params.JsonPointer)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "json-pointer", Err: err})
		return
	}

	// ------------- Optional query parameter "relative-json-pointer" -------------

	err = runtime.BindQueryParameter("form", true, false, "relative-json-pointer", r.URL.Query(), &params.RelativeJsonPointer)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "relative-json-pointer", Err: err})
		return
	}

	// ------------- Optional query parameter "regex" -------------

	err = runtime.BindQueryParameter("form", true, false, "regex", r.URL.Query(), &params.Regex)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "regex", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAnythingJsonschemaFormats(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetAnythingNumbers operation middleware
func (siw *ServerInterfaceWrapper) GetAnythingNumbers(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAnythingNumbersParams

	// ------------- Required query parameter "id-required" -------------

	if paramValue := r.URL.Query().Get("id-required"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id-required"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id-required", r.URL.Query(), &params.IdRequired)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id-required", Err: err})
		return
	}

	// ------------- Optional query parameter "id-optional" -------------

	err = runtime.BindQueryParameter("form", true, false, "id-optional", r.URL.Query(), &params.IdOptional)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id-optional", Err: err})
		return
	}

	// ------------- Required query parameter "id-exclusive-required" -------------

	if paramValue := r.URL.Query().Get("id-exclusive-required"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id-exclusive-required"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id-exclusive-required", r.URL.Query(), &params.IdExclusiveRequired)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id-exclusive-required", Err: err})
		return
	}

	// ------------- Optional query parameter "id-exclusive-optional" -------------

	err = runtime.BindQueryParameter("form", true, false, "id-exclusive-optional", r.URL.Query(), &params.IdExclusiveOptional)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id-exclusive-optional", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAnythingNumbers(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetAnythingOasFormats operation middleware
func (siw *ServerInterfaceWrapper) GetAnythingOasFormats(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAnythingOasFormatsParams

	// ------------- Required query parameter "int32" -------------

	if paramValue := r.URL.Query().Get("int32"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "int32"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "int32", r.URL.Query(), &params.Int32)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "int32", Err: err})
		return
	}

	// ------------- Optional query parameter "int64" -------------

	err = runtime.BindQueryParameter("form", true, false, "int64", r.URL.Query(), &params.Int64)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "int64", Err: err})
		return
	}

	// ------------- Optional query parameter "float" -------------

	err = runtime.BindQueryParameter("form", true, false, "float", r.URL.Query(), &params.Float)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "float", Err: err})
		return
	}

	// ------------- Optional query parameter "double" -------------

	err = runtime.BindQueryParameter("form", true, false, "double", r.URL.Query(), &params.Double)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "double", Err: err})
		return
	}

	// ------------- Optional query parameter "byte" -------------

	err = runtime.BindQueryParameter("form", true, false, "byte", r.URL.Query(), &params.Byte)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "byte", Err: err})
		return
	}

	// ------------- Optional query parameter "binary" -------------

	err = runtime.BindQueryParameter("form", true, false, "binary", r.URL.Query(), &params.Binary)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "binary", Err: err})
		return
	}

	// ------------- Optional query parameter "password" -------------

	err = runtime.BindQueryParameter("form", true, false, "password", r.URL.Query(), &params.Password)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "password", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAnythingOasFormats(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetAnythingStrings operation middleware
func (siw *ServerInterfaceWrapper) GetAnythingStrings(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAnythingStringsParams

	// ------------- Required query parameter "name-length-required" -------------

	if paramValue := r.URL.Query().Get("name-length-required"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "name-length-required"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "name-length-required", r.URL.Query(), &params.NameLengthRequired)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name-length-required", Err: err})
		return
	}

	// ------------- Optional query parameter "name-length-optional" -------------

	err = runtime.BindQueryParameter("form", true, false, "name-length-optional", r.URL.Query(), &params.NameLengthOptional)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name-length-optional", Err: err})
		return
	}

	// ------------- Required query parameter "name-pattern-required" -------------

	if paramValue := r.URL.Query().Get("name-pattern-required"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "name-pattern-required"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "name-pattern-required", r.URL.Query(), &params.NamePatternRequired)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name-pattern-required", Err: err})
		return
	}

	// ------------- Required query parameter "complex-pattern-required" -------------

	if paramValue := r.URL.Query().Get("complex-pattern-required"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "complex-pattern-required"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "complex-pattern-required", r.URL.Query(), &params.ComplexPatternRequired)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "complex-pattern-required", Err: err})
		return
	}

	// ------------- Optional query parameter "name-pattern-optional" -------------

	err = runtime.BindQueryParameter("form", true, false, "name-pattern-optional", r.URL.Query(), &params.NamePatternOptional)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name-pattern-optional", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAnythingStrings(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       *http.ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m *http.ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m *http.ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/anything/booleans", wrapper.GetAnythingBooleans)
	m.HandleFunc("GET "+options.BaseURL+"/anything/jsonschema-formats", wrapper.GetAnythingJsonschemaFormats)
	m.HandleFunc("GET "+options.BaseURL+"/anything/numbers", wrapper.GetAnythingNumbers)
	m.HandleFunc("GET "+options.BaseURL+"/anything/oas-formats", wrapper.GetAnythingOasFormats)
	m.HandleFunc("GET "+options.BaseURL+"/anything/strings", wrapper.GetAnythingStrings)

	return m
}

type GetAnythingBooleansRequestObject struct {
	Params GetAnythingBooleansParams
}

type GetAnythingBooleansResponseObject interface {
	VisitGetAnythingBooleansResponse(w http.ResponseWriter) error
}

type GetAnythingBooleans200Response struct {
}

func (response GetAnythingBooleans200Response) VisitGetAnythingBooleansResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type GetAnythingJsonschemaFormatsRequestObject struct {
	Params GetAnythingJsonschemaFormatsParams
}

type GetAnythingJsonschemaFormatsResponseObject interface {
	VisitGetAnythingJsonschemaFormatsResponse(w http.ResponseWriter) error
}

type GetAnythingJsonschemaFormats200Response struct {
}

func (response GetAnythingJsonschemaFormats200Response) VisitGetAnythingJsonschemaFormatsResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type GetAnythingNumbersRequestObject struct {
	Params GetAnythingNumbersParams
}

type GetAnythingNumbersResponseObject interface {
	VisitGetAnythingNumbersResponse(w http.ResponseWriter) error
}

type GetAnythingNumbers200Response struct {
}

func (response GetAnythingNumbers200Response) VisitGetAnythingNumbersResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type GetAnythingOasFormatsRequestObject struct {
	Params GetAnythingOasFormatsParams
}

type GetAnythingOasFormatsResponseObject interface {
	VisitGetAnythingOasFormatsResponse(w http.ResponseWriter) error
}

type GetAnythingOasFormats200Response struct {
}

func (response GetAnythingOasFormats200Response) VisitGetAnythingOasFormatsResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type GetAnythingStringsRequestObject struct {
	Params GetAnythingStringsParams
}

type GetAnythingStringsResponseObject interface {
	VisitGetAnythingStringsResponse(w http.ResponseWriter) error
}

type GetAnythingStrings200Response struct {
}

func (response GetAnythingStrings200Response) VisitGetAnythingStringsResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Booleans
	// (GET /anything/booleans)
	GetAnythingBooleans(ctx context.Context, request GetAnythingBooleansRequestObject) (GetAnythingBooleansResponseObject, error)
	// Formats defined by JSON Schema
	// (GET /anything/jsonschema-formats)
	GetAnythingJsonschemaFormats(ctx context.Context, request GetAnythingJsonschemaFormatsRequestObject) (GetAnythingJsonschemaFormatsResponseObject, error)
	// Number validation
	// (GET /anything/numbers)
	GetAnythingNumbers(ctx context.Context, request GetAnythingNumbersRequestObject) (GetAnythingNumbersResponseObject, error)
	// Formats defined by OpenAPI
	// (GET /anything/oas-formats)
	GetAnythingOasFormats(ctx context.Context, request GetAnythingOasFormatsRequestObject) (GetAnythingOasFormatsResponseObject, error)
	// String validation
	// (GET /anything/strings)
	GetAnythingStrings(ctx context.Context, request GetAnythingStringsRequestObject) (GetAnythingStringsResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// GetAnythingBooleans operation middleware
func (sh *strictHandler) GetAnythingBooleans(w http.ResponseWriter, r *http.Request, params GetAnythingBooleansParams) {
	var request GetAnythingBooleansRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetAnythingBooleans(ctx, request.(GetAnythingBooleansRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetAnythingBooleans")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetAnythingBooleansResponseObject); ok {
		if err := validResponse.VisitGetAnythingBooleansResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetAnythingJsonschemaFormats operation middleware
func (sh *strictHandler) GetAnythingJsonschemaFormats(w http.ResponseWriter, r *http.Request, params GetAnythingJsonschemaFormatsParams) {
	var request GetAnythingJsonschemaFormatsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetAnythingJsonschemaFormats(ctx, request.(GetAnythingJsonschemaFormatsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetAnythingJsonschemaFormats")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetAnythingJsonschemaFormatsResponseObject); ok {
		if err := validResponse.VisitGetAnythingJsonschemaFormatsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetAnythingNumbers operation middleware
func (sh *strictHandler) GetAnythingNumbers(w http.ResponseWriter, r *http.Request, params GetAnythingNumbersParams) {
	var request GetAnythingNumbersRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetAnythingNumbers(ctx, request.(GetAnythingNumbersRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetAnythingNumbers")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetAnythingNumbersResponseObject); ok {
		if err := validResponse.VisitGetAnythingNumbersResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetAnythingOasFormats operation middleware
func (sh *strictHandler) GetAnythingOasFormats(w http.ResponseWriter, r *http.Request, params GetAnythingOasFormatsParams) {
	var request GetAnythingOasFormatsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetAnythingOasFormats(ctx, request.(GetAnythingOasFormatsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetAnythingOasFormats")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetAnythingOasFormatsResponseObject); ok {
		if err := validResponse.VisitGetAnythingOasFormatsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetAnythingStrings operation middleware
func (sh *strictHandler) GetAnythingStrings(w http.ResponseWriter, r *http.Request, params GetAnythingStringsParams) {
	var request GetAnythingStringsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetAnythingStrings(ctx, request.(GetAnythingStringsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetAnythingStrings")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetAnythingStringsResponseObject); ok {
		if err := validResponse.VisitGetAnythingStringsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/8RZW28cSRX+K6UCiV2Yvs54nOmXxKs4KCEbRzhcRNZI1d2np2vTXdWuqvbYMsMDEhIC",
	"HkDiEQkhDRIPrOABCSFB8sB79i8MEoG/gaovM91j97jHXsJEUarrcr7vXKrOqcolpizi2LvEAWeKBEo3",
	"GUkBe/jwnKRZAng+wCHIQNBMUc6wh2OlMulZ1pSqOPfNgKfW0cFj6ygDdvD8sXGcQUAjGhA93fIT7lsp",
	"kQqEdQZCUs6kNTRtc2im4ZcyomKDKkgN7n8KgcIDrKhKNPw34TQHqdBxEENK0LdJQsNCJB7gShD2sGPa",
	"pq0p8gwYySj2cCEcD7CWLbU+FmEXKqZsavmcJ0BY0TuFQtm2ahUKoNXMQrIogB+H2MNfB3VQiftoPUeA",
	"zDiTUEh2bfuq5KNv4Pl8gGWepkRcYA83Visyldh7ic/WOp7MtQKCpKBA6EHtKezh0xzEBR7UPlKRIeA0",
	"pwLCgkXV9JTIYYBlYbqSS0TyRNUDULnWi0giYYDVRaalVUprolfoFw2S1IbBgy4+vJqJ74Kv1V+77VPJ",
	"WSnLiLhIiep24KNyHIUQUQYh8i/Qk+OjZ3UUhaAITbZ69ckKrJJ1O/duJ3Inp+sANRRNoZ/LsTO5t2fY",
	"I8NxX7hDz7W9Pdvcc7+HG37AzmQyNhzXcCYvnLE3nHh7+4Z9z7NtPMClzTeAK5dJJSiblhHTxRXfRKuD",
	"ySZ0f9SK43WoDQu0YTu13lHhXNSn1HXwz4cPW7DPh99pqble3RMPUkI79lrdeiCAhCmYlLegq1ZrdEWk",
	"FtuTBQ2ZsY3Jf371+3//5C8P/vX6Z+8++4X57q9v3v3ypy0yy8WPl4tfLxd/fLBc/Ha5eL1c/Ga5eG0u",
	"F58VH39aLhZNek28nhRjLlXRvJ7h9TaqegOeNtEbonawzw0EPvrH34IYhFmDN2lcHWtZ4hZ8srNR17Z0",
	"93VONZ329mj0rrFLKf0xxx2Yttf800a+OtbEH/fHzwXtgNcFjWdZs9nMpKAik4upJaJA/3WHk7GpzlWL",
	"kg48xb0nPGbmQw4PqpHNMCkB+7MzBEQggAVdIWLVzSYZ65qg2BTW10NbLaRLPmDmjL4qEry4KOw0o6+o",
	"9c83f/j852///PbN5z9qcbtx2e/KZW//3nLrLnajfey2leRNXG5jyTynYef+GsJob7xvwL2JbzhuODTI",
	"aG9sjNzx2Bk5+yO7SD/Nrde9YM8d6vmtfFVh7xB3CtIs6U7U1fZoRLklgYggvrx/OkgIm86vOH1jekiD",
	"yvnWpQKRes68bMw3o7ZBpacCujg0Mk6ZAtHl/4i3j3WL/NDxm9AbQnpCC0iIomdg9ODgWAykgtAqLzqy",
	"xcfVDK2WF7tk96Y2hfMbjhGrbZOXh3BSflltIqWkTeB2ic7y1C9q1o66/FkxjtbFbp9S/Fkl9FYF+BXE",
	"O9XcNNzxouW4DeM6owFOyTlN8xR7rj3AKWXlh6M/8kTRLIGjCHvuytClRbeVFDdctd4HAzgPklzqML2j",
	"dVaCPq5J1jfFur/mW/b/T3XZ0a7vjXt7y3Eib3Mdrp5p+uy/IyK/6DtwhX63vcjU0O0bZ8PRXsNd+nPc",
	"TO+VqMrS+pCdbg0TpsYdhfPQrn8NvFGjswk6Hu0AGiWcqI5YbOrWgKiX9Iz+kOd+AnfVayWlJ6p/sVFy",
	"rCRVIz1znU91ZdEhqR7rKSsjUs64aBdv6yT51eLXTI+NBdszZNndvVWPi/EdM+RxJfRW2/MK4p12pf7H",
	"SIBNVbxjMsAqphJRiQi67oKzGmVofdVJyfnTAmt1itaf+hzt6ewm5e1n/v+XYkaUAsF2NSt5ePjo4FtP",
	"X/gtruTwuwcfP3966JdP5Fqw7v3kk9nX/Ov3yeZLcJk/imf2AZrFNIhro0ikeOu99Ww0QCEHiRhXKBP8",
	"jIaAVAwoZzTgIaAoIVO9SPdRluUKKc51EkRF3dkIThO90FZOgTCJVExUsSbiScJnOozL+TLmeRKiGRev",
	"TPRYoRlnX1HFJ6LRCpVKBIz4ic5JEJBcAqIKxUSinIEMSKYHBAkAJVSBIIlEHQ/eAddmPd/NRWuzf/+D",
	"+97lS9uYECM6MB6dXI7mH9z3jPvtrg8v9+fzH/Sa9uGX8e1i64b4/0Ji6aQ4f0Cc1edILpLGK0HCA5LE",
	"XCrvnr7Szk9Wx9Hq/6Qax9L8ZP7fAAAA//+TaP8rvhoAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
