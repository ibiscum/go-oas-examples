// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gorilla/mux"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// GetAnythingBooleansParams defines parameters for GetAnythingBooleans.
type GetAnythingBooleansParams struct {
	// TfRequired Required parameter boolean true/false
	TfRequired bool `form:"tf-required" json:"tf-required"`

	// TfOptional Optional boolean
	TfOptional *bool `form:"tf-optional,omitempty" json:"tf-optional,omitempty"`
}

// GetAnythingJsonschemaFormatsParams defines parameters for GetAnythingJsonschemaFormats.
type GetAnythingJsonschemaFormatsParams struct {
	// DateTime Optional parameter date-time as string
	DateTime time.Time `form:"date-time" json:"date-time"`

	// Date Optional parameter date as string
	Date *openapi_types.Date `form:"date,omitempty" json:"date,omitempty"`

	// Time Optional parameter time as string
	Time *string `form:"time,omitempty" json:"time,omitempty"`

	// Duration Optional parameter duration as string
	Duration *string `form:"duration,omitempty" json:"duration,omitempty"`

	// Email Optional parameter email as string
	Email *openapi_types.Email `form:"email,omitempty" json:"email,omitempty"`

	// IdnEmail Optional parameter idn-email as string
	IdnEmail *string `form:"idn-email,omitempty" json:"idn-email,omitempty"`

	// Hostname Optional parameter hostname as string
	Hostname *string `form:"hostname,omitempty" json:"hostname,omitempty"`

	// IdnHostname Optional parameter idn-hostname as string
	IdnHostname *string `form:"idn-hostname,omitempty" json:"idn-hostname,omitempty"`

	// Ipv4 Optional parameter ipv4 as string
	Ipv4 *string `form:"ipv4,omitempty" json:"ipv4,omitempty"`

	// Ipv6 Optional parameter ipv6 as string
	Ipv6 *string `form:"ipv6,omitempty" json:"ipv6,omitempty"`

	// Uri Optional parameter uri as string
	Uri *string `form:"uri,omitempty" json:"uri,omitempty"`

	// UriReference Optional parameter uri-reference as string
	UriReference *string `form:"uri-reference,omitempty" json:"uri-reference,omitempty"`

	// Iri Optional parameter iri as string
	Iri *string `form:"iri,omitempty" json:"iri,omitempty"`

	// IriReference Optional parameter iri-reference as string
	IriReference *string `form:"iri-reference,omitempty" json:"iri-reference,omitempty"`

	// Uuid Optional parameter uuid as string
	Uuid *openapi_types.UUID `form:"uuid,omitempty" json:"uuid,omitempty"`

	// UriTemplate Optional parameter uri-template as string
	UriTemplate *string `form:"uri-template,omitempty" json:"uri-template,omitempty"`

	// JsonPointer Optional parameter json-pointer as string
	JsonPointer *string `form:"json-pointer,omitempty" json:"json-pointer,omitempty"`

	// RelativeJsonPointer Optional parameter relative-json-pointer as string
	RelativeJsonPointer *string `form:"relative-json-pointer,omitempty" json:"relative-json-pointer,omitempty"`

	// Regex Optional parameter regex as string
	Regex *string `form:"regex,omitempty" json:"regex,omitempty"`
}

// GetAnythingNumbersParams defines parameters for GetAnythingNumbers.
type GetAnythingNumbersParams struct {
	// IdRequired Required parameter id-required
	IdRequired float32 `form:"id-required" json:"id-required"`

	// IdOptional Optional parameter id-optional
	IdOptional *float32 `form:"id-optional,omitempty" json:"id-optional,omitempty"`

	// IdExclusiveRequired Required parameter id-exclusive-required
	IdExclusiveRequired float32 `form:"id-exclusive-required" json:"id-exclusive-required"`

	// IdExclusiveOptional Optional parameter id-exclusive-optional
	IdExclusiveOptional *float32 `form:"id-exclusive-optional,omitempty" json:"id-exclusive-optional,omitempty"`
}

// GetAnythingOasFormatsParams defines parameters for GetAnythingOasFormats.
type GetAnythingOasFormatsParams struct {
	// Int32 Optional parameter int32 as integer
	Int32 int32 `form:"int32" json:"int32"`

	// Int64 Optional parameter int64 as integer
	Int64 *int64 `form:"int64,omitempty" json:"int64,omitempty"`

	// Float Optional parameter float as number
	Float *float32 `form:"float,omitempty" json:"float,omitempty"`

	// Double Optional parameter double as number
	Double *float64 `form:"double,omitempty" json:"double,omitempty"`

	// Byte Optional parameter byte as string
	Byte *[]byte `form:"byte,omitempty" json:"byte,omitempty"`

	// Binary Optional parameter binary as string
	Binary *openapi_types.File `form:"binary,omitempty" json:"binary,omitempty"`

	// Password Optional parameter password
	Password *string `form:"password,omitempty" json:"password,omitempty"`
}

// GetAnythingStringsParams defines parameters for GetAnythingStrings.
type GetAnythingStringsParams struct {
	// NameLengthRequired Required parameter name-length-required
	NameLengthRequired string `form:"name-length-required" json:"name-length-required"`

	// NameLengthOptional Optional parameter name-length-optional
	NameLengthOptional *string `form:"name-length-optional,omitempty" json:"name-length-optional,omitempty"`

	// NamePatternRequired Required parameter name-pattern-required
	NamePatternRequired string `form:"name-pattern-required" json:"name-pattern-required"`

	// ComplexPatternRequired OpenAPI 3.0.3, which defaults to JSON Schema v4, does not provide the unicode flag to the input tooltip regex validation. This means that the following regex should work. It won't work if unicode is enabled because it has unescaped brace literals
	ComplexPatternRequired string `form:"complex-pattern-required" json:"complex-pattern-required"`

	// NamePatternOptional Optional parameter name-pattern-optional as string
	NamePatternOptional *string `form:"name-pattern-optional,omitempty" json:"name-pattern-optional,omitempty"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Booleans
	// (GET /anything/booleans)
	GetAnythingBooleans(w http.ResponseWriter, r *http.Request, params GetAnythingBooleansParams)
	// Formats defined by JSON Schema
	// (GET /anything/jsonschema-formats)
	GetAnythingJsonschemaFormats(w http.ResponseWriter, r *http.Request, params GetAnythingJsonschemaFormatsParams)
	// Number validation
	// (GET /anything/numbers)
	GetAnythingNumbers(w http.ResponseWriter, r *http.Request, params GetAnythingNumbersParams)
	// Formats defined by OpenAPI
	// (GET /anything/oas-formats)
	GetAnythingOasFormats(w http.ResponseWriter, r *http.Request, params GetAnythingOasFormatsParams)
	// String validation
	// (GET /anything/strings)
	GetAnythingStrings(w http.ResponseWriter, r *http.Request, params GetAnythingStringsParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetAnythingBooleans operation middleware
func (siw *ServerInterfaceWrapper) GetAnythingBooleans(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAnythingBooleansParams

	// ------------- Required query parameter "tf-required" -------------

	if paramValue := r.URL.Query().Get("tf-required"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "tf-required"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "tf-required", r.URL.Query(), &params.TfRequired)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tf-required", Err: err})
		return
	}

	// ------------- Optional query parameter "tf-optional" -------------

	err = runtime.BindQueryParameter("form", true, false, "tf-optional", r.URL.Query(), &params.TfOptional)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tf-optional", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAnythingBooleans(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetAnythingJsonschemaFormats operation middleware
func (siw *ServerInterfaceWrapper) GetAnythingJsonschemaFormats(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAnythingJsonschemaFormatsParams

	// ------------- Required query parameter "date-time" -------------

	if paramValue := r.URL.Query().Get("date-time"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "date-time"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "date-time", r.URL.Query(), &params.DateTime)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "date-time", Err: err})
		return
	}

	// ------------- Optional query parameter "date" -------------

	err = runtime.BindQueryParameter("form", true, false, "date", r.URL.Query(), &params.Date)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "date", Err: err})
		return
	}

	// ------------- Optional query parameter "time" -------------

	err = runtime.BindQueryParameter("form", true, false, "time", r.URL.Query(), &params.Time)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "time", Err: err})
		return
	}

	// ------------- Optional query parameter "duration" -------------

	err = runtime.BindQueryParameter("form", true, false, "duration", r.URL.Query(), &params.Duration)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "duration", Err: err})
		return
	}

	// ------------- Optional query parameter "email" -------------

	err = runtime.BindQueryParameter("form", true, false, "email", r.URL.Query(), &params.Email)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "email", Err: err})
		return
	}

	// ------------- Optional query parameter "idn-email" -------------

	err = runtime.BindQueryParameter("form", true, false, "idn-email", r.URL.Query(), &params.IdnEmail)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "idn-email", Err: err})
		return
	}

	// ------------- Optional query parameter "hostname" -------------

	err = runtime.BindQueryParameter("form", true, false, "hostname", r.URL.Query(), &params.Hostname)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "hostname", Err: err})
		return
	}

	// ------------- Optional query parameter "idn-hostname" -------------

	err = runtime.BindQueryParameter("form", true, false, "idn-hostname", r.URL.Query(), &params.IdnHostname)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "idn-hostname", Err: err})
		return
	}

	// ------------- Optional query parameter "ipv4" -------------

	err = runtime.BindQueryParameter("form", true, false, "ipv4", r.URL.Query(), &params.Ipv4)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ipv4", Err: err})
		return
	}

	// ------------- Optional query parameter "ipv6" -------------

	err = runtime.BindQueryParameter("form", true, false, "ipv6", r.URL.Query(), &params.Ipv6)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ipv6", Err: err})
		return
	}

	// ------------- Optional query parameter "uri" -------------

	err = runtime.BindQueryParameter("form", true, false, "uri", r.URL.Query(), &params.Uri)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "uri", Err: err})
		return
	}

	// ------------- Optional query parameter "uri-reference" -------------

	err = runtime.BindQueryParameter("form", true, false, "uri-reference", r.URL.Query(), &params.UriReference)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "uri-reference", Err: err})
		return
	}

	// ------------- Optional query parameter "iri" -------------

	err = runtime.BindQueryParameter("form", true, false, "iri", r.URL.Query(), &params.Iri)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "iri", Err: err})
		return
	}

	// ------------- Optional query parameter "iri-reference" -------------

	err = runtime.BindQueryParameter("form", true, false, "iri-reference", r.URL.Query(), &params.IriReference)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "iri-reference", Err: err})
		return
	}

	// ------------- Optional query parameter "uuid" -------------

	err = runtime.BindQueryParameter("form", true, false, "uuid", r.URL.Query(), &params.Uuid)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "uuid", Err: err})
		return
	}

	// ------------- Optional query parameter "uri-template" -------------

	err = runtime.BindQueryParameter("form", true, false, "uri-template", r.URL.Query(), &params.UriTemplate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "uri-template", Err: err})
		return
	}

	// ------------- Optional query parameter "json-pointer" -------------

	err = runtime.BindQueryParameter("form", true, false, "json-pointer", r.URL.Query(), &params.JsonPointer)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "json-pointer", Err: err})
		return
	}

	// ------------- Optional query parameter "relative-json-pointer" -------------

	err = runtime.BindQueryParameter("form", true, false, "relative-json-pointer", r.URL.Query(), &params.RelativeJsonPointer)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "relative-json-pointer", Err: err})
		return
	}

	// ------------- Optional query parameter "regex" -------------

	err = runtime.BindQueryParameter("form", true, false, "regex", r.URL.Query(), &params.Regex)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "regex", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAnythingJsonschemaFormats(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetAnythingNumbers operation middleware
func (siw *ServerInterfaceWrapper) GetAnythingNumbers(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAnythingNumbersParams

	// ------------- Required query parameter "id-required" -------------

	if paramValue := r.URL.Query().Get("id-required"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id-required"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id-required", r.URL.Query(), &params.IdRequired)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id-required", Err: err})
		return
	}

	// ------------- Optional query parameter "id-optional" -------------

	err = runtime.BindQueryParameter("form", true, false, "id-optional", r.URL.Query(), &params.IdOptional)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id-optional", Err: err})
		return
	}

	// ------------- Required query parameter "id-exclusive-required" -------------

	if paramValue := r.URL.Query().Get("id-exclusive-required"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id-exclusive-required"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id-exclusive-required", r.URL.Query(), &params.IdExclusiveRequired)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id-exclusive-required", Err: err})
		return
	}

	// ------------- Optional query parameter "id-exclusive-optional" -------------

	err = runtime.BindQueryParameter("form", true, false, "id-exclusive-optional", r.URL.Query(), &params.IdExclusiveOptional)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id-exclusive-optional", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAnythingNumbers(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetAnythingOasFormats operation middleware
func (siw *ServerInterfaceWrapper) GetAnythingOasFormats(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAnythingOasFormatsParams

	// ------------- Required query parameter "int32" -------------

	if paramValue := r.URL.Query().Get("int32"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "int32"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "int32", r.URL.Query(), &params.Int32)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "int32", Err: err})
		return
	}

	// ------------- Optional query parameter "int64" -------------

	err = runtime.BindQueryParameter("form", true, false, "int64", r.URL.Query(), &params.Int64)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "int64", Err: err})
		return
	}

	// ------------- Optional query parameter "float" -------------

	err = runtime.BindQueryParameter("form", true, false, "float", r.URL.Query(), &params.Float)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "float", Err: err})
		return
	}

	// ------------- Optional query parameter "double" -------------

	err = runtime.BindQueryParameter("form", true, false, "double", r.URL.Query(), &params.Double)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "double", Err: err})
		return
	}

	// ------------- Optional query parameter "byte" -------------

	err = runtime.BindQueryParameter("form", true, false, "byte", r.URL.Query(), &params.Byte)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "byte", Err: err})
		return
	}

	// ------------- Optional query parameter "binary" -------------

	err = runtime.BindQueryParameter("form", true, false, "binary", r.URL.Query(), &params.Binary)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "binary", Err: err})
		return
	}

	// ------------- Optional query parameter "password" -------------

	err = runtime.BindQueryParameter("form", true, false, "password", r.URL.Query(), &params.Password)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "password", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAnythingOasFormats(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetAnythingStrings operation middleware
func (siw *ServerInterfaceWrapper) GetAnythingStrings(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAnythingStringsParams

	// ------------- Required query parameter "name-length-required" -------------

	if paramValue := r.URL.Query().Get("name-length-required"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "name-length-required"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "name-length-required", r.URL.Query(), &params.NameLengthRequired)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name-length-required", Err: err})
		return
	}

	// ------------- Optional query parameter "name-length-optional" -------------

	err = runtime.BindQueryParameter("form", true, false, "name-length-optional", r.URL.Query(), &params.NameLengthOptional)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name-length-optional", Err: err})
		return
	}

	// ------------- Required query parameter "name-pattern-required" -------------

	if paramValue := r.URL.Query().Get("name-pattern-required"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "name-pattern-required"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "name-pattern-required", r.URL.Query(), &params.NamePatternRequired)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name-pattern-required", Err: err})
		return
	}

	// ------------- Required query parameter "complex-pattern-required" -------------

	if paramValue := r.URL.Query().Get("complex-pattern-required"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "complex-pattern-required"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "complex-pattern-required", r.URL.Query(), &params.ComplexPatternRequired)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "complex-pattern-required", Err: err})
		return
	}

	// ------------- Optional query parameter "name-pattern-optional" -------------

	err = runtime.BindQueryParameter("form", true, false, "name-pattern-optional", r.URL.Query(), &params.NamePatternOptional)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name-pattern-optional", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAnythingStrings(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, GorillaServerOptions{})
}

type GorillaServerOptions struct {
	BaseURL          string
	BaseRouter       *mux.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r *mux.Router) http.Handler {
	return HandlerWithOptions(si, GorillaServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r *mux.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, GorillaServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options GorillaServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = mux.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.HandleFunc(options.BaseURL+"/anything/booleans", wrapper.GetAnythingBooleans).Methods("GET")

	r.HandleFunc(options.BaseURL+"/anything/jsonschema-formats", wrapper.GetAnythingJsonschemaFormats).Methods("GET")

	r.HandleFunc(options.BaseURL+"/anything/numbers", wrapper.GetAnythingNumbers).Methods("GET")

	r.HandleFunc(options.BaseURL+"/anything/oas-formats", wrapper.GetAnythingOasFormats).Methods("GET")

	r.HandleFunc(options.BaseURL+"/anything/strings", wrapper.GetAnythingStrings).Methods("GET")

	return r
}

type GetAnythingBooleansRequestObject struct {
	Params GetAnythingBooleansParams
}

type GetAnythingBooleansResponseObject interface {
	VisitGetAnythingBooleansResponse(w http.ResponseWriter) error
}

type GetAnythingBooleans200Response struct {
}

func (response GetAnythingBooleans200Response) VisitGetAnythingBooleansResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type GetAnythingJsonschemaFormatsRequestObject struct {
	Params GetAnythingJsonschemaFormatsParams
}

type GetAnythingJsonschemaFormatsResponseObject interface {
	VisitGetAnythingJsonschemaFormatsResponse(w http.ResponseWriter) error
}

type GetAnythingJsonschemaFormats200Response struct {
}

func (response GetAnythingJsonschemaFormats200Response) VisitGetAnythingJsonschemaFormatsResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type GetAnythingNumbersRequestObject struct {
	Params GetAnythingNumbersParams
}

type GetAnythingNumbersResponseObject interface {
	VisitGetAnythingNumbersResponse(w http.ResponseWriter) error
}

type GetAnythingNumbers200Response struct {
}

func (response GetAnythingNumbers200Response) VisitGetAnythingNumbersResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type GetAnythingOasFormatsRequestObject struct {
	Params GetAnythingOasFormatsParams
}

type GetAnythingOasFormatsResponseObject interface {
	VisitGetAnythingOasFormatsResponse(w http.ResponseWriter) error
}

type GetAnythingOasFormats200Response struct {
}

func (response GetAnythingOasFormats200Response) VisitGetAnythingOasFormatsResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type GetAnythingStringsRequestObject struct {
	Params GetAnythingStringsParams
}

type GetAnythingStringsResponseObject interface {
	VisitGetAnythingStringsResponse(w http.ResponseWriter) error
}

type GetAnythingStrings200Response struct {
}

func (response GetAnythingStrings200Response) VisitGetAnythingStringsResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Booleans
	// (GET /anything/booleans)
	GetAnythingBooleans(ctx context.Context, request GetAnythingBooleansRequestObject) (GetAnythingBooleansResponseObject, error)
	// Formats defined by JSON Schema
	// (GET /anything/jsonschema-formats)
	GetAnythingJsonschemaFormats(ctx context.Context, request GetAnythingJsonschemaFormatsRequestObject) (GetAnythingJsonschemaFormatsResponseObject, error)
	// Number validation
	// (GET /anything/numbers)
	GetAnythingNumbers(ctx context.Context, request GetAnythingNumbersRequestObject) (GetAnythingNumbersResponseObject, error)
	// Formats defined by OpenAPI
	// (GET /anything/oas-formats)
	GetAnythingOasFormats(ctx context.Context, request GetAnythingOasFormatsRequestObject) (GetAnythingOasFormatsResponseObject, error)
	// String validation
	// (GET /anything/strings)
	GetAnythingStrings(ctx context.Context, request GetAnythingStringsRequestObject) (GetAnythingStringsResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// GetAnythingBooleans operation middleware
func (sh *strictHandler) GetAnythingBooleans(w http.ResponseWriter, r *http.Request, params GetAnythingBooleansParams) {
	var request GetAnythingBooleansRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetAnythingBooleans(ctx, request.(GetAnythingBooleansRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetAnythingBooleans")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetAnythingBooleansResponseObject); ok {
		if err := validResponse.VisitGetAnythingBooleansResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetAnythingJsonschemaFormats operation middleware
func (sh *strictHandler) GetAnythingJsonschemaFormats(w http.ResponseWriter, r *http.Request, params GetAnythingJsonschemaFormatsParams) {
	var request GetAnythingJsonschemaFormatsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetAnythingJsonschemaFormats(ctx, request.(GetAnythingJsonschemaFormatsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetAnythingJsonschemaFormats")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetAnythingJsonschemaFormatsResponseObject); ok {
		if err := validResponse.VisitGetAnythingJsonschemaFormatsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetAnythingNumbers operation middleware
func (sh *strictHandler) GetAnythingNumbers(w http.ResponseWriter, r *http.Request, params GetAnythingNumbersParams) {
	var request GetAnythingNumbersRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetAnythingNumbers(ctx, request.(GetAnythingNumbersRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetAnythingNumbers")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetAnythingNumbersResponseObject); ok {
		if err := validResponse.VisitGetAnythingNumbersResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetAnythingOasFormats operation middleware
func (sh *strictHandler) GetAnythingOasFormats(w http.ResponseWriter, r *http.Request, params GetAnythingOasFormatsParams) {
	var request GetAnythingOasFormatsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetAnythingOasFormats(ctx, request.(GetAnythingOasFormatsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetAnythingOasFormats")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetAnythingOasFormatsResponseObject); ok {
		if err := validResponse.VisitGetAnythingOasFormatsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetAnythingStrings operation middleware
func (sh *strictHandler) GetAnythingStrings(w http.ResponseWriter, r *http.Request, params GetAnythingStringsParams) {
	var request GetAnythingStringsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetAnythingStrings(ctx, request.(GetAnythingStringsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetAnythingStrings")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetAnythingStringsResponseObject); ok {
		if err := validResponse.VisitGetAnythingStringsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
