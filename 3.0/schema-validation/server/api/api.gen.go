// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gorilla/mux"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// GetAnythingBooleansParams defines parameters for GetAnythingBooleans.
type GetAnythingBooleansParams struct {
	TfRequired bool `form:"tf-required" json:"tf-required"`

	// TfOptional Optional boolean
	TfOptional *bool `form:"tf-optional,omitempty" json:"tf-optional,omitempty"`
}

// GetAnythingJsonschemaFormatsParams defines parameters for GetAnythingJsonschemaFormats.
type GetAnythingJsonschemaFormatsParams struct {
	DateTime            time.Time            `form:"date-time" json:"date-time"`
	Date                *openapi_types.Date  `form:"date,omitempty" json:"date,omitempty"`
	Time                *string              `form:"time,omitempty" json:"time,omitempty"`
	Duration            *string              `form:"duration,omitempty" json:"duration,omitempty"`
	Email               *openapi_types.Email `form:"email,omitempty" json:"email,omitempty"`
	IdnEmail            *string              `form:"idn-email,omitempty" json:"idn-email,omitempty"`
	Hostname            *string              `form:"hostname,omitempty" json:"hostname,omitempty"`
	IdnHostname         *string              `form:"idn-hostname,omitempty" json:"idn-hostname,omitempty"`
	Ipv4                *string              `form:"ipv4,omitempty" json:"ipv4,omitempty"`
	Ipv6                *string              `form:"ipv6,omitempty" json:"ipv6,omitempty"`
	Uri                 *string              `form:"uri,omitempty" json:"uri,omitempty"`
	UriReference        *string              `form:"uri-reference,omitempty" json:"uri-reference,omitempty"`
	Iri                 *string              `form:"iri,omitempty" json:"iri,omitempty"`
	IriReference        *string              `form:"iri-reference,omitempty" json:"iri-reference,omitempty"`
	Uuid                *openapi_types.UUID  `form:"uuid,omitempty" json:"uuid,omitempty"`
	UriTemplate         *string              `form:"uri-template,omitempty" json:"uri-template,omitempty"`
	JsonPointer         *string              `form:"json-pointer,omitempty" json:"json-pointer,omitempty"`
	RelativeJsonPointer *string              `form:"relative-json-pointer,omitempty" json:"relative-json-pointer,omitempty"`
	Regex               *string              `form:"regex,omitempty" json:"regex,omitempty"`
}

// GetAnythingNumbersParams defines parameters for GetAnythingNumbers.
type GetAnythingNumbersParams struct {
	IdRequired          float32  `form:"id-required" json:"id-required"`
	IdOptional          *float32 `form:"id-optional,omitempty" json:"id-optional,omitempty"`
	IdExclusiveRequired float32  `form:"id-exclusive-required" json:"id-exclusive-required"`
	IdExclusiveOptional *float32 `form:"id-exclusive-optional,omitempty" json:"id-exclusive-optional,omitempty"`
}

// GetAnythingOasFormatsParams defines parameters for GetAnythingOasFormats.
type GetAnythingOasFormatsParams struct {
	Int32    int32               `form:"int32" json:"int32"`
	Int64    *int64              `form:"int64,omitempty" json:"int64,omitempty"`
	Float    *float32            `form:"float,omitempty" json:"float,omitempty"`
	Double   *float64            `form:"double,omitempty" json:"double,omitempty"`
	Byte     *[]byte             `form:"byte,omitempty" json:"byte,omitempty"`
	Binary   *openapi_types.File `form:"binary,omitempty" json:"binary,omitempty"`
	Password *string             `form:"password,omitempty" json:"password,omitempty"`
}

// GetAnythingStringsParams defines parameters for GetAnythingStrings.
type GetAnythingStringsParams struct {
	NameLengthRequired  string  `form:"name-length-required" json:"name-length-required"`
	NameLengthOptional  *string `form:"name-length-optional,omitempty" json:"name-length-optional,omitempty"`
	NamePatternRequired string  `form:"name-pattern-required" json:"name-pattern-required"`

	// ComplexPatternRequired OpenAPI 3.0.3, which defaults to JSON Schema v4, does not provide the unicode flag to the input tooltip regex validation. This means that the following regex should work. It won't work if unicode is enabled because it has unescaped brace literals
	ComplexPatternRequired string  `form:"complex-pattern-required" json:"complex-pattern-required"`
	NamePatternOptional    *string `form:"name-pattern-optional,omitempty" json:"name-pattern-optional,omitempty"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Booleans
	// (GET /anything/booleans)
	GetAnythingBooleans(w http.ResponseWriter, r *http.Request, params GetAnythingBooleansParams)
	// Formats defined by JSON Schema
	// (GET /anything/jsonschema-formats)
	GetAnythingJsonschemaFormats(w http.ResponseWriter, r *http.Request, params GetAnythingJsonschemaFormatsParams)
	// Number validation
	// (GET /anything/numbers)
	GetAnythingNumbers(w http.ResponseWriter, r *http.Request, params GetAnythingNumbersParams)
	// Formats defined by OpenAPI
	// (GET /anything/oas-formats)
	GetAnythingOasFormats(w http.ResponseWriter, r *http.Request, params GetAnythingOasFormatsParams)
	// String validation
	// (GET /anything/strings)
	GetAnythingStrings(w http.ResponseWriter, r *http.Request, params GetAnythingStringsParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetAnythingBooleans operation middleware
func (siw *ServerInterfaceWrapper) GetAnythingBooleans(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAnythingBooleansParams

	// ------------- Required query parameter "tf-required" -------------

	if paramValue := r.URL.Query().Get("tf-required"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "tf-required"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "tf-required", r.URL.Query(), &params.TfRequired)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tf-required", Err: err})
		return
	}

	// ------------- Optional query parameter "tf-optional" -------------

	err = runtime.BindQueryParameter("form", true, false, "tf-optional", r.URL.Query(), &params.TfOptional)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tf-optional", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAnythingBooleans(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetAnythingJsonschemaFormats operation middleware
func (siw *ServerInterfaceWrapper) GetAnythingJsonschemaFormats(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAnythingJsonschemaFormatsParams

	// ------------- Required query parameter "date-time" -------------

	if paramValue := r.URL.Query().Get("date-time"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "date-time"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "date-time", r.URL.Query(), &params.DateTime)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "date-time", Err: err})
		return
	}

	// ------------- Optional query parameter "date" -------------

	err = runtime.BindQueryParameter("form", true, false, "date", r.URL.Query(), &params.Date)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "date", Err: err})
		return
	}

	// ------------- Optional query parameter "time" -------------

	err = runtime.BindQueryParameter("form", true, false, "time", r.URL.Query(), &params.Time)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "time", Err: err})
		return
	}

	// ------------- Optional query parameter "duration" -------------

	err = runtime.BindQueryParameter("form", true, false, "duration", r.URL.Query(), &params.Duration)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "duration", Err: err})
		return
	}

	// ------------- Optional query parameter "email" -------------

	err = runtime.BindQueryParameter("form", true, false, "email", r.URL.Query(), &params.Email)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "email", Err: err})
		return
	}

	// ------------- Optional query parameter "idn-email" -------------

	err = runtime.BindQueryParameter("form", true, false, "idn-email", r.URL.Query(), &params.IdnEmail)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "idn-email", Err: err})
		return
	}

	// ------------- Optional query parameter "hostname" -------------

	err = runtime.BindQueryParameter("form", true, false, "hostname", r.URL.Query(), &params.Hostname)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "hostname", Err: err})
		return
	}

	// ------------- Optional query parameter "idn-hostname" -------------

	err = runtime.BindQueryParameter("form", true, false, "idn-hostname", r.URL.Query(), &params.IdnHostname)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "idn-hostname", Err: err})
		return
	}

	// ------------- Optional query parameter "ipv4" -------------

	err = runtime.BindQueryParameter("form", true, false, "ipv4", r.URL.Query(), &params.Ipv4)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ipv4", Err: err})
		return
	}

	// ------------- Optional query parameter "ipv6" -------------

	err = runtime.BindQueryParameter("form", true, false, "ipv6", r.URL.Query(), &params.Ipv6)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ipv6", Err: err})
		return
	}

	// ------------- Optional query parameter "uri" -------------

	err = runtime.BindQueryParameter("form", true, false, "uri", r.URL.Query(), &params.Uri)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "uri", Err: err})
		return
	}

	// ------------- Optional query parameter "uri-reference" -------------

	err = runtime.BindQueryParameter("form", true, false, "uri-reference", r.URL.Query(), &params.UriReference)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "uri-reference", Err: err})
		return
	}

	// ------------- Optional query parameter "iri" -------------

	err = runtime.BindQueryParameter("form", true, false, "iri", r.URL.Query(), &params.Iri)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "iri", Err: err})
		return
	}

	// ------------- Optional query parameter "iri-reference" -------------

	err = runtime.BindQueryParameter("form", true, false, "iri-reference", r.URL.Query(), &params.IriReference)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "iri-reference", Err: err})
		return
	}

	// ------------- Optional query parameter "uuid" -------------

	err = runtime.BindQueryParameter("form", true, false, "uuid", r.URL.Query(), &params.Uuid)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "uuid", Err: err})
		return
	}

	// ------------- Optional query parameter "uri-template" -------------

	err = runtime.BindQueryParameter("form", true, false, "uri-template", r.URL.Query(), &params.UriTemplate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "uri-template", Err: err})
		return
	}

	// ------------- Optional query parameter "json-pointer" -------------

	err = runtime.BindQueryParameter("form", true, false, "json-pointer", r.URL.Query(), &params.JsonPointer)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "json-pointer", Err: err})
		return
	}

	// ------------- Optional query parameter "relative-json-pointer" -------------

	err = runtime.BindQueryParameter("form", true, false, "relative-json-pointer", r.URL.Query(), &params.RelativeJsonPointer)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "relative-json-pointer", Err: err})
		return
	}

	// ------------- Optional query parameter "regex" -------------

	err = runtime.BindQueryParameter("form", true, false, "regex", r.URL.Query(), &params.Regex)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "regex", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAnythingJsonschemaFormats(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetAnythingNumbers operation middleware
func (siw *ServerInterfaceWrapper) GetAnythingNumbers(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAnythingNumbersParams

	// ------------- Required query parameter "id-required" -------------

	if paramValue := r.URL.Query().Get("id-required"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id-required"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id-required", r.URL.Query(), &params.IdRequired)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id-required", Err: err})
		return
	}

	// ------------- Optional query parameter "id-optional" -------------

	err = runtime.BindQueryParameter("form", true, false, "id-optional", r.URL.Query(), &params.IdOptional)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id-optional", Err: err})
		return
	}

	// ------------- Required query parameter "id-exclusive-required" -------------

	if paramValue := r.URL.Query().Get("id-exclusive-required"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id-exclusive-required"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id-exclusive-required", r.URL.Query(), &params.IdExclusiveRequired)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id-exclusive-required", Err: err})
		return
	}

	// ------------- Optional query parameter "id-exclusive-optional" -------------

	err = runtime.BindQueryParameter("form", true, false, "id-exclusive-optional", r.URL.Query(), &params.IdExclusiveOptional)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id-exclusive-optional", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAnythingNumbers(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetAnythingOasFormats operation middleware
func (siw *ServerInterfaceWrapper) GetAnythingOasFormats(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAnythingOasFormatsParams

	// ------------- Required query parameter "int32" -------------

	if paramValue := r.URL.Query().Get("int32"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "int32"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "int32", r.URL.Query(), &params.Int32)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "int32", Err: err})
		return
	}

	// ------------- Optional query parameter "int64" -------------

	err = runtime.BindQueryParameter("form", true, false, "int64", r.URL.Query(), &params.Int64)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "int64", Err: err})
		return
	}

	// ------------- Optional query parameter "float" -------------

	err = runtime.BindQueryParameter("form", true, false, "float", r.URL.Query(), &params.Float)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "float", Err: err})
		return
	}

	// ------------- Optional query parameter "double" -------------

	err = runtime.BindQueryParameter("form", true, false, "double", r.URL.Query(), &params.Double)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "double", Err: err})
		return
	}

	// ------------- Optional query parameter "byte" -------------

	err = runtime.BindQueryParameter("form", true, false, "byte", r.URL.Query(), &params.Byte)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "byte", Err: err})
		return
	}

	// ------------- Optional query parameter "binary" -------------

	err = runtime.BindQueryParameter("form", true, false, "binary", r.URL.Query(), &params.Binary)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "binary", Err: err})
		return
	}

	// ------------- Optional query parameter "password" -------------

	err = runtime.BindQueryParameter("form", true, false, "password", r.URL.Query(), &params.Password)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "password", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAnythingOasFormats(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetAnythingStrings operation middleware
func (siw *ServerInterfaceWrapper) GetAnythingStrings(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAnythingStringsParams

	// ------------- Required query parameter "name-length-required" -------------

	if paramValue := r.URL.Query().Get("name-length-required"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "name-length-required"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "name-length-required", r.URL.Query(), &params.NameLengthRequired)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name-length-required", Err: err})
		return
	}

	// ------------- Optional query parameter "name-length-optional" -------------

	err = runtime.BindQueryParameter("form", true, false, "name-length-optional", r.URL.Query(), &params.NameLengthOptional)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name-length-optional", Err: err})
		return
	}

	// ------------- Required query parameter "name-pattern-required" -------------

	if paramValue := r.URL.Query().Get("name-pattern-required"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "name-pattern-required"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "name-pattern-required", r.URL.Query(), &params.NamePatternRequired)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name-pattern-required", Err: err})
		return
	}

	// ------------- Required query parameter "complex-pattern-required" -------------

	if paramValue := r.URL.Query().Get("complex-pattern-required"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "complex-pattern-required"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "complex-pattern-required", r.URL.Query(), &params.ComplexPatternRequired)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "complex-pattern-required", Err: err})
		return
	}

	// ------------- Optional query parameter "name-pattern-optional" -------------

	err = runtime.BindQueryParameter("form", true, false, "name-pattern-optional", r.URL.Query(), &params.NamePatternOptional)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name-pattern-optional", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAnythingStrings(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, GorillaServerOptions{})
}

type GorillaServerOptions struct {
	BaseURL          string
	BaseRouter       *mux.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r *mux.Router) http.Handler {
	return HandlerWithOptions(si, GorillaServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r *mux.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, GorillaServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options GorillaServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = mux.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.HandleFunc(options.BaseURL+"/anything/booleans", wrapper.GetAnythingBooleans).Methods("GET")

	r.HandleFunc(options.BaseURL+"/anything/jsonschema-formats", wrapper.GetAnythingJsonschemaFormats).Methods("GET")

	r.HandleFunc(options.BaseURL+"/anything/numbers", wrapper.GetAnythingNumbers).Methods("GET")

	r.HandleFunc(options.BaseURL+"/anything/oas-formats", wrapper.GetAnythingOasFormats).Methods("GET")

	r.HandleFunc(options.BaseURL+"/anything/strings", wrapper.GetAnythingStrings).Methods("GET")

	return r
}

type GetAnythingBooleansRequestObject struct {
	Params GetAnythingBooleansParams
}

type GetAnythingBooleansResponseObject interface {
	VisitGetAnythingBooleansResponse(w http.ResponseWriter) error
}

type GetAnythingBooleans200Response struct {
}

func (response GetAnythingBooleans200Response) VisitGetAnythingBooleansResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type GetAnythingJsonschemaFormatsRequestObject struct {
	Params GetAnythingJsonschemaFormatsParams
}

type GetAnythingJsonschemaFormatsResponseObject interface {
	VisitGetAnythingJsonschemaFormatsResponse(w http.ResponseWriter) error
}

type GetAnythingJsonschemaFormats200Response struct {
}

func (response GetAnythingJsonschemaFormats200Response) VisitGetAnythingJsonschemaFormatsResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type GetAnythingNumbersRequestObject struct {
	Params GetAnythingNumbersParams
}

type GetAnythingNumbersResponseObject interface {
	VisitGetAnythingNumbersResponse(w http.ResponseWriter) error
}

type GetAnythingNumbers200Response struct {
}

func (response GetAnythingNumbers200Response) VisitGetAnythingNumbersResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type GetAnythingOasFormatsRequestObject struct {
	Params GetAnythingOasFormatsParams
}

type GetAnythingOasFormatsResponseObject interface {
	VisitGetAnythingOasFormatsResponse(w http.ResponseWriter) error
}

type GetAnythingOasFormats200Response struct {
}

func (response GetAnythingOasFormats200Response) VisitGetAnythingOasFormatsResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type GetAnythingStringsRequestObject struct {
	Params GetAnythingStringsParams
}

type GetAnythingStringsResponseObject interface {
	VisitGetAnythingStringsResponse(w http.ResponseWriter) error
}

type GetAnythingStrings200Response struct {
}

func (response GetAnythingStrings200Response) VisitGetAnythingStringsResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Booleans
	// (GET /anything/booleans)
	GetAnythingBooleans(ctx context.Context, request GetAnythingBooleansRequestObject) (GetAnythingBooleansResponseObject, error)
	// Formats defined by JSON Schema
	// (GET /anything/jsonschema-formats)
	GetAnythingJsonschemaFormats(ctx context.Context, request GetAnythingJsonschemaFormatsRequestObject) (GetAnythingJsonschemaFormatsResponseObject, error)
	// Number validation
	// (GET /anything/numbers)
	GetAnythingNumbers(ctx context.Context, request GetAnythingNumbersRequestObject) (GetAnythingNumbersResponseObject, error)
	// Formats defined by OpenAPI
	// (GET /anything/oas-formats)
	GetAnythingOasFormats(ctx context.Context, request GetAnythingOasFormatsRequestObject) (GetAnythingOasFormatsResponseObject, error)
	// String validation
	// (GET /anything/strings)
	GetAnythingStrings(ctx context.Context, request GetAnythingStringsRequestObject) (GetAnythingStringsResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// GetAnythingBooleans operation middleware
func (sh *strictHandler) GetAnythingBooleans(w http.ResponseWriter, r *http.Request, params GetAnythingBooleansParams) {
	var request GetAnythingBooleansRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetAnythingBooleans(ctx, request.(GetAnythingBooleansRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetAnythingBooleans")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetAnythingBooleansResponseObject); ok {
		if err := validResponse.VisitGetAnythingBooleansResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetAnythingJsonschemaFormats operation middleware
func (sh *strictHandler) GetAnythingJsonschemaFormats(w http.ResponseWriter, r *http.Request, params GetAnythingJsonschemaFormatsParams) {
	var request GetAnythingJsonschemaFormatsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetAnythingJsonschemaFormats(ctx, request.(GetAnythingJsonschemaFormatsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetAnythingJsonschemaFormats")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetAnythingJsonschemaFormatsResponseObject); ok {
		if err := validResponse.VisitGetAnythingJsonschemaFormatsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetAnythingNumbers operation middleware
func (sh *strictHandler) GetAnythingNumbers(w http.ResponseWriter, r *http.Request, params GetAnythingNumbersParams) {
	var request GetAnythingNumbersRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetAnythingNumbers(ctx, request.(GetAnythingNumbersRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetAnythingNumbers")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetAnythingNumbersResponseObject); ok {
		if err := validResponse.VisitGetAnythingNumbersResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetAnythingOasFormats operation middleware
func (sh *strictHandler) GetAnythingOasFormats(w http.ResponseWriter, r *http.Request, params GetAnythingOasFormatsParams) {
	var request GetAnythingOasFormatsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetAnythingOasFormats(ctx, request.(GetAnythingOasFormatsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetAnythingOasFormats")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetAnythingOasFormatsResponseObject); ok {
		if err := validResponse.VisitGetAnythingOasFormatsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetAnythingStrings operation middleware
func (sh *strictHandler) GetAnythingStrings(w http.ResponseWriter, r *http.Request, params GetAnythingStringsParams) {
	var request GetAnythingStringsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetAnythingStrings(ctx, request.(GetAnythingStringsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetAnythingStrings")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetAnythingStringsResponseObject); ok {
		if err := validResponse.VisitGetAnythingStringsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
