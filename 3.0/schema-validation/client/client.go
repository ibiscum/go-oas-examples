// Package client provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package client

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// GetAnythingBooleansParams defines parameters for GetAnythingBooleans.
type GetAnythingBooleansParams struct {
	TfRequired bool `form:"tf-required" json:"tf-required"`

	// TfOptional Optional boolean
	TfOptional *bool `form:"tf-optional,omitempty" json:"tf-optional,omitempty"`
}

// GetAnythingJsonschemaFormatsParams defines parameters for GetAnythingJsonschemaFormats.
type GetAnythingJsonschemaFormatsParams struct {
	DateTime            time.Time            `form:"date-time" json:"date-time"`
	Date                *openapi_types.Date  `form:"date,omitempty" json:"date,omitempty"`
	Time                *string              `form:"time,omitempty" json:"time,omitempty"`
	Duration            *string              `form:"duration,omitempty" json:"duration,omitempty"`
	Email               *openapi_types.Email `form:"email,omitempty" json:"email,omitempty"`
	IdnEmail            *string              `form:"idn-email,omitempty" json:"idn-email,omitempty"`
	Hostname            *string              `form:"hostname,omitempty" json:"hostname,omitempty"`
	IdnHostname         *string              `form:"idn-hostname,omitempty" json:"idn-hostname,omitempty"`
	Ipv4                *string              `form:"ipv4,omitempty" json:"ipv4,omitempty"`
	Ipv6                *string              `form:"ipv6,omitempty" json:"ipv6,omitempty"`
	Uri                 *string              `form:"uri,omitempty" json:"uri,omitempty"`
	UriReference        *string              `form:"uri-reference,omitempty" json:"uri-reference,omitempty"`
	Iri                 *string              `form:"iri,omitempty" json:"iri,omitempty"`
	IriReference        *string              `form:"iri-reference,omitempty" json:"iri-reference,omitempty"`
	Uuid                *openapi_types.UUID  `form:"uuid,omitempty" json:"uuid,omitempty"`
	UriTemplate         *string              `form:"uri-template,omitempty" json:"uri-template,omitempty"`
	JsonPointer         *string              `form:"json-pointer,omitempty" json:"json-pointer,omitempty"`
	RelativeJsonPointer *string              `form:"relative-json-pointer,omitempty" json:"relative-json-pointer,omitempty"`
	Regex               *string              `form:"regex,omitempty" json:"regex,omitempty"`
}

// GetAnythingNumbersParams defines parameters for GetAnythingNumbers.
type GetAnythingNumbersParams struct {
	IdRequired          float32  `form:"id-required" json:"id-required"`
	IdOptional          *float32 `form:"id-optional,omitempty" json:"id-optional,omitempty"`
	IdExclusiveRequired float32  `form:"id-exclusive-required" json:"id-exclusive-required"`
	IdExclusiveOptional *float32 `form:"id-exclusive-optional,omitempty" json:"id-exclusive-optional,omitempty"`
}

// GetAnythingOasFormatsParams defines parameters for GetAnythingOasFormats.
type GetAnythingOasFormatsParams struct {
	Int32    int32               `form:"int32" json:"int32"`
	Int64    *int64              `form:"int64,omitempty" json:"int64,omitempty"`
	Float    *float32            `form:"float,omitempty" json:"float,omitempty"`
	Double   *float64            `form:"double,omitempty" json:"double,omitempty"`
	Byte     *[]byte             `form:"byte,omitempty" json:"byte,omitempty"`
	Binary   *openapi_types.File `form:"binary,omitempty" json:"binary,omitempty"`
	Password *string             `form:"password,omitempty" json:"password,omitempty"`
}

// GetAnythingStringsParams defines parameters for GetAnythingStrings.
type GetAnythingStringsParams struct {
	NameLengthRequired  string  `form:"name-length-required" json:"name-length-required"`
	NameLengthOptional  *string `form:"name-length-optional,omitempty" json:"name-length-optional,omitempty"`
	NamePatternRequired string  `form:"name-pattern-required" json:"name-pattern-required"`

	// ComplexPatternRequired OpenAPI 3.0.3, which defaults to JSON Schema v4, does not provide the unicode flag to the input tooltip regex validation. This means that the following regex should work. It won't work if unicode is enabled because it has unescaped brace literals
	ComplexPatternRequired string  `form:"complex-pattern-required" json:"complex-pattern-required"`
	NamePatternOptional    *string `form:"name-pattern-optional,omitempty" json:"name-pattern-optional,omitempty"`
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAnythingBooleans request
	GetAnythingBooleans(ctx context.Context, params *GetAnythingBooleansParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnythingJsonschemaFormats request
	GetAnythingJsonschemaFormats(ctx context.Context, params *GetAnythingJsonschemaFormatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnythingNumbers request
	GetAnythingNumbers(ctx context.Context, params *GetAnythingNumbersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnythingOasFormats request
	GetAnythingOasFormats(ctx context.Context, params *GetAnythingOasFormatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnythingStrings request
	GetAnythingStrings(ctx context.Context, params *GetAnythingStringsParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAnythingBooleans(ctx context.Context, params *GetAnythingBooleansParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnythingBooleansRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnythingJsonschemaFormats(ctx context.Context, params *GetAnythingJsonschemaFormatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnythingJsonschemaFormatsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnythingNumbers(ctx context.Context, params *GetAnythingNumbersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnythingNumbersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnythingOasFormats(ctx context.Context, params *GetAnythingOasFormatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnythingOasFormatsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnythingStrings(ctx context.Context, params *GetAnythingStringsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnythingStringsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAnythingBooleansRequest generates requests for GetAnythingBooleans
func NewGetAnythingBooleansRequest(server string, params *GetAnythingBooleansParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anything/booleans")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tf-required", runtime.ParamLocationQuery, params.TfRequired); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TfOptional != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tf-optional", runtime.ParamLocationQuery, *params.TfOptional); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnythingJsonschemaFormatsRequest generates requests for GetAnythingJsonschemaFormats
func NewGetAnythingJsonschemaFormatsRequest(server string, params *GetAnythingJsonschemaFormatsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anything/jsonschema-formats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date-time", runtime.ParamLocationQuery, params.DateTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Time != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time", runtime.ParamLocationQuery, *params.Time); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Duration != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "duration", runtime.ParamLocationQuery, *params.Duration); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Email != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "email", runtime.ParamLocationQuery, *params.Email); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IdnEmail != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "idn-email", runtime.ParamLocationQuery, *params.IdnEmail); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Hostname != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hostname", runtime.ParamLocationQuery, *params.Hostname); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IdnHostname != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "idn-hostname", runtime.ParamLocationQuery, *params.IdnHostname); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ipv4 != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ipv4", runtime.ParamLocationQuery, *params.Ipv4); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ipv6 != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ipv6", runtime.ParamLocationQuery, *params.Ipv6); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Uri != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "uri", runtime.ParamLocationQuery, *params.Uri); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UriReference != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "uri-reference", runtime.ParamLocationQuery, *params.UriReference); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Iri != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "iri", runtime.ParamLocationQuery, *params.Iri); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IriReference != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "iri-reference", runtime.ParamLocationQuery, *params.IriReference); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Uuid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "uuid", runtime.ParamLocationQuery, *params.Uuid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UriTemplate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "uri-template", runtime.ParamLocationQuery, *params.UriTemplate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JsonPointer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "json-pointer", runtime.ParamLocationQuery, *params.JsonPointer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RelativeJsonPointer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "relative-json-pointer", runtime.ParamLocationQuery, *params.RelativeJsonPointer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Regex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "regex", runtime.ParamLocationQuery, *params.Regex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnythingNumbersRequest generates requests for GetAnythingNumbers
func NewGetAnythingNumbersRequest(server string, params *GetAnythingNumbersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anything/numbers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id-required", runtime.ParamLocationQuery, params.IdRequired); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.IdOptional != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id-optional", runtime.ParamLocationQuery, *params.IdOptional); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id-exclusive-required", runtime.ParamLocationQuery, params.IdExclusiveRequired); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.IdExclusiveOptional != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id-exclusive-optional", runtime.ParamLocationQuery, *params.IdExclusiveOptional); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnythingOasFormatsRequest generates requests for GetAnythingOasFormats
func NewGetAnythingOasFormatsRequest(server string, params *GetAnythingOasFormatsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anything/oas-formats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "int32", runtime.ParamLocationQuery, params.Int32); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Int64 != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "int64", runtime.ParamLocationQuery, *params.Int64); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Float != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "float", runtime.ParamLocationQuery, *params.Float); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Double != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "double", runtime.ParamLocationQuery, *params.Double); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Byte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "byte", runtime.ParamLocationQuery, *params.Byte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Binary != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "binary", runtime.ParamLocationQuery, *params.Binary); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Password != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "password", runtime.ParamLocationQuery, *params.Password); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnythingStringsRequest generates requests for GetAnythingStrings
func NewGetAnythingStringsRequest(server string, params *GetAnythingStringsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anything/strings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name-length-required", runtime.ParamLocationQuery, params.NameLengthRequired); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.NameLengthOptional != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name-length-optional", runtime.ParamLocationQuery, *params.NameLengthOptional); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name-pattern-required", runtime.ParamLocationQuery, params.NamePatternRequired); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "complex-pattern-required", runtime.ParamLocationQuery, params.ComplexPatternRequired); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.NamePatternOptional != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name-pattern-optional", runtime.ParamLocationQuery, *params.NamePatternOptional); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAnythingBooleansWithResponse request
	GetAnythingBooleansWithResponse(ctx context.Context, params *GetAnythingBooleansParams, reqEditors ...RequestEditorFn) (*GetAnythingBooleansResponse, error)

	// GetAnythingJsonschemaFormatsWithResponse request
	GetAnythingJsonschemaFormatsWithResponse(ctx context.Context, params *GetAnythingJsonschemaFormatsParams, reqEditors ...RequestEditorFn) (*GetAnythingJsonschemaFormatsResponse, error)

	// GetAnythingNumbersWithResponse request
	GetAnythingNumbersWithResponse(ctx context.Context, params *GetAnythingNumbersParams, reqEditors ...RequestEditorFn) (*GetAnythingNumbersResponse, error)

	// GetAnythingOasFormatsWithResponse request
	GetAnythingOasFormatsWithResponse(ctx context.Context, params *GetAnythingOasFormatsParams, reqEditors ...RequestEditorFn) (*GetAnythingOasFormatsResponse, error)

	// GetAnythingStringsWithResponse request
	GetAnythingStringsWithResponse(ctx context.Context, params *GetAnythingStringsParams, reqEditors ...RequestEditorFn) (*GetAnythingStringsResponse, error)
}

type GetAnythingBooleansResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetAnythingBooleansResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnythingBooleansResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnythingJsonschemaFormatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetAnythingJsonschemaFormatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnythingJsonschemaFormatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnythingNumbersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetAnythingNumbersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnythingNumbersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnythingOasFormatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetAnythingOasFormatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnythingOasFormatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnythingStringsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetAnythingStringsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnythingStringsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAnythingBooleansWithResponse request returning *GetAnythingBooleansResponse
func (c *ClientWithResponses) GetAnythingBooleansWithResponse(ctx context.Context, params *GetAnythingBooleansParams, reqEditors ...RequestEditorFn) (*GetAnythingBooleansResponse, error) {
	rsp, err := c.GetAnythingBooleans(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnythingBooleansResponse(rsp)
}

// GetAnythingJsonschemaFormatsWithResponse request returning *GetAnythingJsonschemaFormatsResponse
func (c *ClientWithResponses) GetAnythingJsonschemaFormatsWithResponse(ctx context.Context, params *GetAnythingJsonschemaFormatsParams, reqEditors ...RequestEditorFn) (*GetAnythingJsonschemaFormatsResponse, error) {
	rsp, err := c.GetAnythingJsonschemaFormats(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnythingJsonschemaFormatsResponse(rsp)
}

// GetAnythingNumbersWithResponse request returning *GetAnythingNumbersResponse
func (c *ClientWithResponses) GetAnythingNumbersWithResponse(ctx context.Context, params *GetAnythingNumbersParams, reqEditors ...RequestEditorFn) (*GetAnythingNumbersResponse, error) {
	rsp, err := c.GetAnythingNumbers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnythingNumbersResponse(rsp)
}

// GetAnythingOasFormatsWithResponse request returning *GetAnythingOasFormatsResponse
func (c *ClientWithResponses) GetAnythingOasFormatsWithResponse(ctx context.Context, params *GetAnythingOasFormatsParams, reqEditors ...RequestEditorFn) (*GetAnythingOasFormatsResponse, error) {
	rsp, err := c.GetAnythingOasFormats(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnythingOasFormatsResponse(rsp)
}

// GetAnythingStringsWithResponse request returning *GetAnythingStringsResponse
func (c *ClientWithResponses) GetAnythingStringsWithResponse(ctx context.Context, params *GetAnythingStringsParams, reqEditors ...RequestEditorFn) (*GetAnythingStringsResponse, error) {
	rsp, err := c.GetAnythingStrings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnythingStringsResponse(rsp)
}

// ParseGetAnythingBooleansResponse parses an HTTP response from a GetAnythingBooleansWithResponse call
func ParseGetAnythingBooleansResponse(rsp *http.Response) (*GetAnythingBooleansResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnythingBooleansResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAnythingJsonschemaFormatsResponse parses an HTTP response from a GetAnythingJsonschemaFormatsWithResponse call
func ParseGetAnythingJsonschemaFormatsResponse(rsp *http.Response) (*GetAnythingJsonschemaFormatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnythingJsonschemaFormatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAnythingNumbersResponse parses an HTTP response from a GetAnythingNumbersWithResponse call
func ParseGetAnythingNumbersResponse(rsp *http.Response) (*GetAnythingNumbersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnythingNumbersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAnythingOasFormatsResponse parses an HTTP response from a GetAnythingOasFormatsWithResponse call
func ParseGetAnythingOasFormatsResponse(rsp *http.Response) (*GetAnythingOasFormatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnythingOasFormatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAnythingStringsResponse parses an HTTP response from a GetAnythingStringsWithResponse call
func ParseGetAnythingStringsResponse(rsp *http.Response) (*GetAnythingStringsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnythingStringsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
